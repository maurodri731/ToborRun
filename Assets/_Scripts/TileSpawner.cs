using System.Collections.Generic;
using UnityEngine;

namespace ToborRun {

public class TileSpawner : MonoBehaviour
{
    //The following is basic variable declaration, to improve code readability wherever they are applied
    [SerializeField]
    private int tilseStartCount = 10;
    [SerializeField]
    private int minimumStraightTiles = 3;
    [SerializeField]
    private int maximumStraightTiles = 15;
    [SerializeField]
    private GameObject startingTile;
    [SerializeField]
    private List<GameObject> turnTiles;
    [SerializeField]
    private List<GameObject> obstacles;

    private Vector3 currentTileLocation = Vector3.zero;
    private Vector3 currentTileDirection = Vector3.forward;
    private GameObject prevTile;

    private List<GameObject> currentTiles;
    private List<GameObject> currentObstacles;

    private void Start(){
        currentTiles = new List<GameObject>();//initialize Tiles and obstacles
        currentObstacles = new List<GameObject>();

        Random.InitState(System.DateTime.Now.Millisecond);

        //note that the first line of tiles spawned DO NOT contain obstacles!!!
        for (int i = 0; i < tilseStartCount; i++){//control the initial tiles' spawn
            SpawnTile(startingTile.GetComponent<Tile>());//spawn tiles without spawning obstacles
        }

        SpawnTile(SelectRandomGameObjectFromList(turnTiles).GetComponent<Tile>());//spawn the initial turn, ONLY the turn is spawned, not the turn and a line
        /* Optional Test, requires you to comment out the line above
        //The following two lines were used to test the generation of tiles after the initial turn. The inital line of tiles should not be seen and the new line could have obstacles
        SpawnTile(turnTiles[0].GetComponent<Tile>());//This line spawns an initial left turn after the initial tiles but...
        AddNewDirection(Vector3.left);//...the tiles generated by the for loop above are deleted by this function call, which is why they aren't seen. However...
        //...it spawns another line AFTER the turn that actually has a chance to spawn obstacles, this new line has a turn in its end*/
    }

    private void SpawnTile(Tile tile, bool spawnObstacle = false){
        //spawn tile towards the direction of movement
        Quaternion newTileRotation = tile.gameObject.transform.rotation * Quaternion.LookRotation(currentTileDirection, Vector3.up);
        prevTile = GameObject.Instantiate(tile.gameObject, currentTileLocation, newTileRotation);
        currentTiles.Add(prevTile);//add it to the tile list

        if(spawnObstacle) SpawnObstacle();//chance of spawning an obstacle, but the chance only exists if spawnObstacle is true 
        if(tile.type == TileType.STRAIGHT)//add an offset for next tile location if the direction is straight
            currentTileLocation += Vector3.Scale(prevTile.GetComponent<Renderer>().bounds.size, currentTileDirection);
    }

    private void DeletePreviousTiles() {//called when direction is changed, not an ideal solution but this can be optimized at another time (Object Pooling)
        while (currentTiles.Count != 1){
            GameObject tile = currentTiles[0];
            currentTiles.RemoveAt(0);
            Destroy(tile);
        }

        while (currentObstacles.Count != 0){
            GameObject obstacle = currentObstacles[0];
            currentObstacles.RemoveAt(0);
            Destroy(obstacle);
        }
    }

    public void AddNewDirection(Vector3 direction) {
        currentTileDirection = direction;//set the new current direction
        DeletePreviousTiles();//delete previous tiles

        Vector3 tilePlacementScale;//determine placement of the new tile, depends on the type of turn tile
        if (prevTile.GetComponent<Tile>().type == TileType.SIDEWAYS){
            tilePlacementScale = Vector3.Scale(prevTile.GetComponent<Renderer>().bounds.size / 2 + (Vector3.one * 
                startingTile.GetComponent<BoxCollider>().size.z / 2), currentTileDirection);
        }
        else{//left or right tiles
            tilePlacementScale = Vector3.Scale((prevTile.GetComponent<Renderer>().bounds.size - (Vector3.one * 2)) + (Vector3.one * 
                startingTile.GetComponent<BoxCollider>().size.z / 2), currentTileDirection);
        }

        currentTileLocation += tilePlacementScale;//add placement to current location

        int currentPathLength = Random.Range(minimumStraightTiles, maximumStraightTiles);//spawn a number of straight tiles
        for(int i = 0; i < currentPathLength; i++){
            SpawnTile(startingTile.GetComponent<Tile>(), (i == 0) ? false : true);
        }

        //spawn another turn tile
        SpawnTile(SelectRandomGameObjectFromList(turnTiles).GetComponent<Tile>(), false);
    }

    private void SpawnObstacle() {
        if (Random.value > 0.4f) return;//there is an 40% change of there being an obstacle at any eligible tile
            
        GameObject obstaclePrefab = SelectRandomGameObjectFromList(obstacles);//select random tile, rotate it according to current direction
        Quaternion newObjectRotation = obstaclePrefab.gameObject.transform.rotation * Quaternion.LookRotation(currentTileDirection, Vector3.up);
        GameObject obstacle = Instantiate(obstaclePrefab, currentTileLocation, newObjectRotation);//spawn and add to the list
        currentObstacles.Add(obstacle);
    }

    private GameObject SelectRandomGameObjectFromList(List<GameObject> list){//helper function to select a random object, used with
        if (list.Count == 0) return null;                                   //tile list and obstacle list
        return list[Random.Range(0, list.Count)];
    }
}

}
